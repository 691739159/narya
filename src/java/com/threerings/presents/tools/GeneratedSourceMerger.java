//
// $Id$
//
// Narya library - tools for developing networked games
// Copyright (C) 2002-2010 Three Rings Design, Inc., All Rights Reserved
// http://www.threerings.net/code/narya/
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

package com.threerings.presents.tools;

import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import com.samskivert.util.Tuple;

/**
 * Merges updates to a generated source file into a previously generated version of that source
 * while leaving changes outside marked sections alone.
 */
public class GeneratedSourceMerger
{
    /**
     * Returns <code>previouslyGenerated</code> with marked sections updated from the same marked
     * sections in <code>newlyGenerated</code> Everything outside these sections in
     * <code>previouslyGenerated</code> is returned as is. A marked section starts with
     * "// GENERATED <name> START" and ends with "// GENERATED <name> END"
     */
    public String merge (String newlyGenerated, String previouslyGenerated)
        throws Exception
    {
        // Extract the generated section names from the output and make sure they're all matched
        Map<String, String> sections = Maps.newLinkedHashMap();
        Matcher m = _sectionDelimiter.matcher(newlyGenerated);
        while (m.find()) {
            Tuple<String, String> section = extractGeneratedSection(m, newlyGenerated);
            Preconditions.checkArgument(!sections.containsKey(section.left),
                "Section '%s' used more than once", section.left);
            sections.put(section.left, section.right);
        }

        // Merge with the previously generated source
        StringBuilder merged = new StringBuilder();
        m = _sectionDelimiter.matcher(previouslyGenerated);
        Iterator<Entry<String, String>> secs = sections.entrySet().iterator();
        int currentStart = 0;
        while (m.find()) {
            merged.append(previouslyGenerated.substring(currentStart, m.start()));
            Tuple<String, String> existingSection =
                extractGeneratedSection(m, previouslyGenerated);
            // Allow generated sections to be dropped in the template, but warn in case something
            // odd's happening
            if (!secs.hasNext()) {
                System.err.println("Dropping previously generated section '" + m.group(1)
                    + "' that's no longer generated by the template");
            }
            // However, we don't allow sections to be removed or reordered in the generated code
            Entry<String, String> newSection = secs.next();
            Preconditions.checkArgument(newSection.getKey().equals(existingSection.left),
                "Generated code expected '%s' section, but encountered '%s'", newSection.getKey(),
                existingSection.left);
            // Pop in the newly generated code in the place of what was there before
            merged.append(newSection.getValue());
            currentStart = m.end();
        }
        // Add generated sections that weren't present in the old output before the last
        // non-generated code.  It's a 50-50 shot, so warn when this happens
        while(secs.hasNext()) {
            Entry<String, String> newSection = secs.next();
            System.err.println("Adding previously missing generated section '"
                + newSection.getKey() + "' before the last non-generated text");
            merged.append(newSection.getValue());
        }
        // Add any text past the last previously generated section
        merged.append(previouslyGenerated.substring(currentStart));

        return merged.toString();
    }

    /**
     * Returns a section name and its contents from the given matcher pointing to the start of a
     * section. <code>m</code> is at the end of the section when this returns.
     */
    protected Tuple<String, String> extractGeneratedSection (Matcher m, String input)
    {
        int startIdx = m.start();
        String startName = m.group(1);
        Preconditions.checkArgument(m.group(2).equals("START"), "'%s' END without START",
            startName);
        Preconditions.checkArgument(m.find(), "'%s' START without END", startName);
        String endName = m.group(1);
        Preconditions.checkArgument(m.group(2).equals("END"),
            "'%s' START after '%s' START", endName, startName);
        Preconditions.checkArgument(endName.equals(startName),
            "'%s' END after '%s' START", endName, startName);
        return Tuple.newTuple(startName, input.substring(startIdx, m.end()));
    }

    protected final Pattern _sectionDelimiter = Pattern.compile(" *// GENERATED (\\w+) (START|END)\n");
}
